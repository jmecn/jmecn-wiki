= jMonkeyEngine 3 教程 (2) - 节点
:author: (翻译 jmecn)
:revnumber:
:revdate: 2018/01/22 16:47
:keywords: beginner, rootNode, node, intro, documentation, color, spatial, geometry, scenegraph, mesh
:relfileprefix: ../
:imagesdir: ..
ifdef::env-github,env-browser[:outfilesuffix: .adoc]


上一篇: <<beginner/hello_simpleapplication#,SimpleApplication>>,
下一篇: <<beginner/hello_asset#,加载资产>>.

在这个教程，我们来学习3d场景的创建。

* 这个教程假设你了解 <<jme3/the_scene_graph#,the Scene Graph>> 。
* 或者查看 <<jme3/scenegraph_for_dummies#,Scene Graph for Dummies>> 。

在创建一个3d游戏

. 要创景一些场景对象，比如玩家，建筑等。
. 要把这些对象添加到场景
. 要给予这些对象：移动，旋转，改变大小，上色和动画

在这里你会学到：场景是如何表达一个3d世界, rooNode的重要性。你会学到：如何创建简单的对象，如何让它们携带自定义数据（比如血量）和如何“变换”它们（移动，旋转，改变大小）。你会学到两个空间物体的不同：Nodes（节点）和Geometries（几何体）。

== 示例

[source,java]
----
package jme3test.helloworld;

import com.jme3.app.SimpleApplication;
import com.jme3.material.Material;
import com.jme3.math.ColorRGBA;
import com.jme3.math.Vector3f;
import com.jme3.scene.Geometry;
import com.jme3.scene.Node;
import com.jme3.scene.shape.Box;

/** Sample 2 - How to use nodes as handles to manipulate objects in the scene.
 * You can rotate, translate, and scale objects by manipulating their parent nodes.
 * The Root Node is special: Only what is attached to the Root Node appears in the scene. 
 * 你可以通过变换对象的父节点来变换对象。
 * 根节点（rootNode）是特别的：这有附着在根节点的对象才会被渲染到画布。*/
public class HelloNode extends SimpleApplication {

    public static void main(String[] args){
        HelloNode app = new HelloNode();
        app.start();
    }

    @Override
    public void simpleInitApp() {

        /** create a blue box at coordinates (1,-1,1) 
            在坐标（1,-1,1）创建蓝方块*/
        Box box1 = new Box(1,1,1);
        Geometry blue = new Geometry("Box", box1);
        blue.setLocalTranslation(new Vector3f(1,-1,1));
        Material mat1 = new Material(assetManager,
                "Common/MatDefs/Misc/Unshaded.j3md");
        mat1.setColor("Color", ColorRGBA.Blue);
        blue.setMaterial(mat1);

        /** create a red box straight above the blue one at (1,3,1) 
            在坐标（1,3，1）创建红方块*/
        Box box2 = new Box(1,1,1);
        Geometry red = new Geometry("Box", box2);
        red.setLocalTranslation(new Vector3f(1,3,1));
        Material mat2 = new Material(assetManager,
                "Common/MatDefs/Misc/Unshaded.j3md");
        mat2.setColor("Color", ColorRGBA.Red);
        red.setMaterial(mat2);

        /** Create a pivot node at (0,0,0) and attach it to the root node 
            根节点坐标（0,0,0）附着上新的节点*/
        Node pivot = new Node("pivot");
        rootNode.attachChild(pivot); // put this node in the scene

        /** Attach the two boxes to the *pivot* node. (And transitively to the root node.) 
            在这个节点附着上方块*/
        pivot.attachChild(blue);
        pivot.attachChild(red);
        /** Rotate the pivot node: Note that both boxes have rotated! 
            选择节点： 注意方块也跟着旋转*/
        pivot.rotate(.4f,.4f,0f);
    }
}
----

编译和运行代码。 你应该看到两个方块，而且它们都有一样的旋转方向。

== 理解术语

在这里，你会学到新的术语：
[cols="2", options="header"]
|===

a|你想怎么做？
a|如何用JME3的术语表达？

a|布置场景。
a|填充对象到场景。

a|创建场景对象。
a|创景空间物体（比如创建几何体）

a|使对象在画布上显示。
a|附着空间物体到rootNode。

a|使对象在画布上消失。
a|解除物体在rootNode的绑定。

a|移动，选择和改变大小
a|移动，选择和改变大小 = 变换对象。

|===

所有JME3应用有一个rootNode： 你的游戏从SimpleApplica自动继承了 `rootNode` 。所有绑定在rootNode的对象是场景的一部分。场景的组成是空间物体。

* 空间物体包括物体的位移，旋转和大小。
* 空间物体可以读取，变换和保存。
* 有两种空间物体：Nodes（节点）和Geometries（几何体）。

[cols="10,45,45", options="header"]
|===

<a|
a| Geometry（几何体）
a| Node（节点）

a| 可见性：
a| 几何体是可见的物体。
a| 节点是不可见的，负责管理场景对象。

a| 目的:
a| 几何体包含对象的形状信息。
a| 节点被几何体和其他节点绑定，从而组成一个群体。

a| 示例:
a| 方块，球体，玩家，建筑，地形，汽车，导弹，NPCs等
a| 根节点，节点包含几个地形，节点包含汽车和乘客，节点包含玩家和武器，音频的节点等

|===


== 了解代码

使用 `simpleInitApp()` 函数来初始化场景，这在第一个教程里有介绍。

. 创建一个方块几何体
** 创建方块形状，运用（1,1,1）的向外延伸。这样会创建一个2x2x2单位长度的方块。
** 使用 setLocalTranslation() 函数把方块放到（1，-1,1）的位置。
** 运用方块形状创建几何体。
** 创建蓝色材质
** 把材质应用到方块几何体上。
.

+
[source,java]
----

    Box box1 = new Box(1,1,1);
    Geometry blue = new Geometry("Box", box1);
    blue.setLocalTranslation(new Vector3f(1,-1,1));
    Material mat1 = new Material(assetManager,"Common/MatDefs/Misc/Unshaded.j3md");
    mat1.setColor("Color", ColorRGBA.Blue);
    blue.setMaterial(mat1);
----


.  创建第二个方块几何体
** 用同样的大小创建第二个方块形状
** 把第二个方块放在（1,3,1），在第一个方块的正上方，2个单位长度的间隔。
** 运用方块形状创建几何体。
** 创建红色材质
** 把材质应用到方块几何体上。
+
[source,java]
----

    Box box2 = new Box(1,1,1);
    Geometry red = new Geometry("Box", box2);
    red.setLocalTranslation(new Vector3f(1,3,1));
    Material mat2 = new Material(assetManager,
      "Common/MatDefs/Misc/Unshaded.j3md");
    mat2.setColor("Color", ColorRGBA.Red);
    red.setMaterial(mat2);
----


.  创建节点
**  给节点命名 `pivot` 。
**  节点默认位置在（1,1,1）。
**  把节点绑定的根节点上。
**  节点在场景上是不可见的。
+
--
[source,java]
----

    Node pivot = new Node("pivot");
    rootNode.attachChild(pivot);
----

如果你的应用只运行到这里，场景是不会有东西显示的。因为节点是不可见的，而且可见的几何体也没有绑定到rootNode上。
--

.  绑定两个方块几何体到pivot节点上.
+
--
[source,java]
----

        pivot.attachChild(blue);
        pivot.attachChild(red);
----

如果你的应用只运行到这里，你会看到两个方块：红色的方块在蓝色的上面。
--

.  旋转pivot节点。
+
[source,java]
----
        pivot.rotate( 0.4f , 0.4f , 0.0f );
----

如果你的应用只运行到这里，你会看到两个方块都向同一个方向旋转。。

=== 什么是 “Pivot” 节点?

你可以相对于“几何体的中心”或者“用户定义的中心”变换（比如，旋转）几何体。这个用户定义的中心就是“Pivor”节点。用户可以用它自定以一个或多个几何体的中心。

在这个实例里，有两个几何体绑定在一个“pivot”节点。通过变换“pivot”节点，同时变换两个几何体。旋转“pivot”节点会同时旋转所有被绑定的几何体。“pivot”节点的中心就是旋转的中心。在绑定其他几何体时，先确定“pivot”节点在坐标（0,0,0）。变换父节点会同时变换所有的子节点。你将会经常用到这个方法。

*例子：* 一辆汽车和它的驾驶员同时移动；一个带有卫星的行星围绕恒星旋转。

这个实例里，如果你不创建“pivot”节点而是只变换几何体，那么所有变换都是相对于几何体自己的中心。

*例子：* 如果旋转每一个方块（用 `red.rotate(0.1f , 0.2f , 0.3f);` 和 `blue.rotate(0.5f , 0.0f , 0.25f);`），那么每个方块都会相对于自身的中心旋转。这就像行星的自转。

== 如何布置场景?
[cols="30,70", options="header"]
|===

a| 目标…?
a| 解决方法!

a| 创建一个空间体（Spatial）.
a| 创建一个网格，把它包装成几何体然后给予它材质。比如：
[source,java]
----
Box mesh = new Box(Vector3f.ZERO, 1, 1, 1); // a cuboid default mesh
Geometry thing = new Geometry("thing", mesh);
Material mat = new Material(assetManager,
   "Common/MatDefs/Misc/ShowNormals.j3md");
thing.setMaterial(mat);
----


a| 在画布显示物体。
a| 绑定空间体到 `rootNode` ，或者任何绑定在 rootNode 的节点。
[source,java]
----
rootNode.attachChild(thing);
----


a| 从画布移除物体。
a| 解除空间体在 `rootNode` 和任何绑定在 rootNode 的节点的绑定。
[source,java]
----
rootNode.detachChild(thing);
----

[source,java]
----
rootNode.detachAllChildren();
----


a| 通过对象名字，ID或父子关系找到空间体。
a| 通过节点的父子找：
[source,java]
----
Spatial thing = rootNode.getChild("thing");
----

[source,java]
----
Spatial twentyThird = rootNode.getChild(22);
----

[source,java]
----
Spatial parent = myNode.getParent();
----


a| 决定什么会在初始是加载。
a| 所有你初始化了同时绑定在 `rootNode` 的对象将是游戏初始场景的一部分。

|===

////
== How do I Transform Spatials?

There are three types of 3D transformation: Translation, Scaling, and Rotation.
////
== 如何变换空间体

变换有3种： 位移，旋转和大小调整

[cols="55,15,15,15", options="header"]
|===
a| 位移会移动空间体
a| X轴
a| Y轴
a| Z轴

a| 用3个维度来表示新的位移： 在原点的位移向 右-上-前 3个方向上移动多少来移动到目标位移，比如(0,40.2f,-2）：
[source,java]
----
thing.setLocalTranslation( new Vector3f( 0.0f, 40.2f, -2.0f ) );
----

 在原来的位移移动一定的量，比如更高(y=40.2f)和更远(z=-2.0f):

[source,java]
----
thing.move( 0.0f, 40.2f, -2.0f );
----

a|+右 -左
a|+上 -下
a|+前 -后

|===
[cols="55,15,15,15", options="header"]
|===

a| Scaling resizes Spatials
a| X-axis
a| Y-axis
a| Z-axis

a|Specify the scaling factor in each dimension: length, height, width. +
A value between 0.0f and 1.0f shrinks the Spatial; bigger than 1.0f stretches it; 1.0f keeps it the same. +
Using the same value for each dimension scales proportionally, different values stretch it. +
To scale a Spatial 10 times longer, one tenth the height, and keep the same width:
[source,java]
----
thing.scale( 10.0f, 0.1f, 1.0f );
----

a|length
a|height
a|width

|===
[cols="55,15,15,15", options="header"]
|===

a| Rotation turns Spatials
a| X-axis (Pitch)
a| Y-axis (Yaw)
a| Z-axis (Roll)

a|3-D rotation is a bit tricky (<<jme3/rotate#,learn details here>>). In short: You can rotate around three axes: Pitch, yaw, and roll. You can specify angles in degrees by multiplying the degrees value with `FastMath.DEG_TO_RAD`. +
To roll an object 180° around the z axis:
[source,java]
----
thing.rotate( 0f , 0f , 180*FastMath.DEG_TO_RAD );
----

Tip: If your game idea calls for a serious amount of rotations, it is worth looking into <<jme3/quaternion#,quaternions>>, a data structure that can combine and store rotations efficiently.

[source,java]
----
thing.setLocalRotation(
  new Quaternion().fromAngleAxis(180*FastMath.DEG_TO_RAD, new Vector3f(1,0,0)));
----

a|nodding your head
a|shaking your head
a|cocking your head

|===


== How do I Troubleshoot Spatials?

If you get unexpected results, check whether you made the following common mistakes:
[cols="40,60", options="header"]
|===

a| Problem?
a| Solution!

a| A created Geometry does not appear in the scene.
a| Have you attached it to (a node that is attached to) the rootNode? +
Does it have a Material? +
What is its translation (position)? +
Is it behind the camera or covered up by another Geometry? +
Is it too tiny or too gigantic to see? +
Is it too far from the camera? (Try link:http://javadoc.jmonkeyengine.org/com/jme3/renderer/Camera.html#setFrustumFar(float)[cam.setFrustumFar](111111f); to see further)

a| A Spatial rotates in unexpected ways.
a| Did you use radian values, and not degrees? (If you used degrees, multiply them with FastMath.DEG_TO_RAD to convert them to radians)  +
Did you create the Spatial at the origin (Vector.ZERO) before moving it? +
Did you rotate around the intended pivot node or around something else? +
Did you rotate around the right axis?

a| A Geometry has an unexpected Color or Material.
<a| Did you reuse a Material from another Geometry and have inadvertently changed its properties? (If so, consider cloning it: mat2 = mat.clone(); )

|===


== How do I Add Custom Data to Spatials?

Many Spatials represent game characters or other entities that the player can interact with. The above code that rotates the two boxes around a common center (pivot) could be used for a spacecraft docked to a orbiting space station, for example.

Depending on your game, game entities do not only change their position, rotation, or scale (the transformations that you just learned about). Game entities also have custom properties, such as health, inventory carried, equipment worn for a character, or hull strength and fuel left for a spacecraft. In Java, you represent entity data as class variables, e.g. floats, Strings, or Arrays.

You can add custom data directly to any Node or Geometry. *You do not need to extend the Node class to include variables*!
For example, to add a custom id number to a node, you would use:

[source,java]
----
pivot.setUserData( "pivot id", 42 );
----

To read this Node's id number elsewhere, you would use:

[source,java]
----
int id = pivot.getUserData( "pivot id" );
----

By using different Strings keys (here the key is `pivot id`), you can get and set several values for whatever data the Spatial needs to carry. When you start writing your game, you might add a fuel value to a car node, speed value to an airplane node, or number of gold coins to a player node, and much more. However, one should note that only custom objects that implements Savable can be passed.


== Conclusion

You have learned that your 3D scene is a scene graph made up of Spatials: Visible Geometries and invisible Nodes. You can transform Spatials, or attach them to nodes and transform the nodes. You know the easiest way how to add custom entity properties (such as player health or vehicle speed) to Spatials.

Since standard shapes like spheres and boxes get old fast, continue with the next chapter where you learn to <<jme3/beginner/hello_asset#,load assets such as 3-D models>>.
